\newpage
\section{Gli standard}

% Storia e basi
\subsection{Storia e basi}

La \hl{standardizzazione di UNIX e' iniziata nel 1988} facendo affidamento ad alcuni \hl{standard di C} dato che fa usi di interfaccie e prototipi.

In definitiva abbiamo gli standard:

\begin{itemize}
	\item Posix.1-2001 / SUSv3: (\url{http://pubs.opengroup.org/onlinepubs/009604599/})
	\item Posix.1-2008 / SUSv4:  più usato in ambiti di automazioni aziendali, infatti sono specializzate sullo scambio di informazione in segnali realtime. Per questo la sua certificazione non è stata presa da nessuno se non fa un IBM. (\url{http://pubs.opengroup.org/onlinepubs/9699919799/})
\end{itemize}

(\hl{PS: le versioni sono back compatibili} quindi se settiamo -D\_XOPEN\_SOURCE=700 non precludiamo la SUSv3)

Nonostante gli standard \hl{ogni OS fa delle sue modifiche su alcune cose esterne alle SUS}.

Per verificare il tipo di standard su un applicativo (\_XOPEN\_SOURCE) o un sistema (\_XOPEN\_VERSION), si fa affidamento alle "\hl{feature test macros}" consultabili dai \textbf{codici di intestazione .h}. Per esempio \_XOPEN\_SOURCE impostata a 600 o 700 indica SUSv3 o SUSv4.

\begin{lstlisting}
-D_XOPEN_SOURCE=600
\end{lstlisting}

in questo modo potremo allora andare a compilare tutti i programmi conformi su qualsiasi OS.


% Limiti
\subsection{Limiti}

Abbiamo dei \hl{limiti di compilazione} che possono essere visti nei file di intestazione.

Possiamo visualizzare i runtime limit che tramite le funzioni: sysconf (es: lunghezza massima del nome dei file che dipende dal filesystem può capirlo tramite pathconf su un file qualunque di quel filesystem)

\begin{itemize}
	\item \hl{sysconf}: usato per \textbf{determinare il valore corrente di un limite}
	
	\item \hl{pathconf}: da \textbf{informazioni sul file system} e per fare ciò gli serve poter arrivare ad un qualunque file del filesystem
	
	\item \hl{fpathconf}: come pathconf ma \textbf{prende il file descriptor}
\end{itemize}

Tutti e 3 prendono come \hl{parametro}:

\begin{lstlisting}
int name
\end{lstlisting}

che \hl{restituisce una chiave} in base a cosa si vuole indagare. In pratica \hl{fanno riferimento ad un nome simbolico che si riferisce ad un valore}.
Tutte queste chiamate fanno si di avere più \textbf{portabilta'}. Se queste chiamate sono fatte da file include \hl{vincono sempre quelli di sysconf. Saranno precedute da \_SC\_ per i sysconf e da \_PC\_ per i pathconf.


% Determinare l'allocazione
\subsection{Determinare l'allocazione}

Supponendo di avere \hl{bisogno di uno spazio} dove mettere un nome di file (path) per poterlo gestire. Per capire quanto spazio devo allocare si utilizza una funzione "path\_alloc". Questa funzione \hl{retituisce un puntatore ad una memoria capace di contenere il massimo dei caratteri}.

Per vedere qual'è la lunghezza usiamo la variabile limite:

\begin{lstlisting}
pathconf(_PC_NAME_MAX)
\end{lstlisting}

in genere avremo NAME\_MAX = 255.


% Definizione di un tipo

pid\_t sono definiti così dato che il progettista vuole lasciare libero il prgrammatore dal tipo 

HOMEWORK: quanto vale?

\begin{lstlisting}
$ grep -rw "pid_t" $INC | grep typedef

/sys/_types/_pid_t.h:typedef __darwin_pid_t pid_t;
/sys/_types.h:typedef __uint32_t __darwin_id_t;

$ grep -rw "__uint32_t" $INC | grep typedef

/i386/_types.h:typedef unsigned int __uint32_t;
\end{lstlisting}

tutti questi rimandi sono dati dalla \hl{portabilita'}



NUOVI CAPITOLO: file IO

in file io co sono le funzioni che fanno il buffered io che gestisce lui e si contrappone da quello dello stdlib. 

chiamata open():

1 arg: path che può essere dato come assoluto o relativo 

2: flag: sono dei bit che dicono cosa fare (es: modalità append)

notare che per le read non appena fatte le scritture il file continua a leggere da dove è stata l'ultima "posizione del file" (current posizion) della read

la prossia write sarà alla fine della read. all'inizio sta a 0 inizo file

avremo che si metterà ad 1 il bit del flag che ci serve tramite:

\begin{lstlisting}
open(file, O_RDWR | O_APPEND | O_CREAT | O_TRUNC, file_mode)
\end{lstlisting}

avremo allora: $11000001010$

con O\_RDWR: 2, O\_APPEND: 8, O\_CREAT: 512, O\_TRUNC: 1024

per lettura e scrittura invece ...



possono essere 3 argomenti quando i file lo stai creando

3. mode: privilegi con cui i file deve essere creato

openat():
si prende il file descriptor di una directory e poi passare un path che viene interpretato con un path relatico a quella directory. quidni ogni cosa viene fatta in questa orecotry anche se nelle directory a monte non si hanno i privilegi

quindi andiamo ad usare open() sulla direcory per avere il file descriptor da usare in openat()


