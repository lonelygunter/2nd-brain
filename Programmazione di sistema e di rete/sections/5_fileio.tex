\newpage
\section{File I/O}


% Introduzione
\subsection{Chiamata open}

I file I/O sono le \hl{funzioni che gestisce buffered I/O} ed in contrapposizione da quelle della libreria "stdlib". La chiamata open() fa parte di queste funzioni, i suoi argomenti sono:

\begin{itemize}
	\item \hl{arg}: path assoluto o relativo
	\item \hl{flag}: bit che indica l'\textbf{attivazione di alcune modalita'}. Si avrà allora a \textbf{settare il bit della flag a 1}:
	\item \hl{mode}: serve a dare i \textbf{privilegi con cui i file deve essere creato} (\textbf{da usare solo nella creazione del file})
\begin{lstlisting}
open(file, O_RDWR | O_APPEND | O_CREAT | O_TRUNC, file_mode)
\end{lstlisting}

		avremo allora $11000001010$ con:
		
		\begin{itemize}
			\item[] O\_RDWR = 2
			\item[] O\_APPEND = 8
			\item[] O\_CREAT = 512
			\item[] O\_TRUNC = 1024
		\end{itemize}
		
\end{itemize}


% Read e write flag
\subsection{Read e write flag}

I \hl{bit delle flag} abbiamo un modo "scomodo" per rappresentarle dato che non seguono la normale "accensione dei singoli bit":

\begin{lstlisting}
#define O_RDONLY   0x0000 /* reading only */
#define O_WRONLY   0x0001 /* writing only */
#define O_RDWR     0x0002 /* reading and writing */
#define O_ACCMODE  0x0003 /* above modes */
\end{lstlisting}

sono dette \hl{maschere} per leggere o scrivere.


% Chiamata openat()
\subsection{Chiamata openat()}

\hl{Prende un file descriptor} (passato dalla open() sulla directory) di una directory per passare il path relativo a quella directory. La sua \hl{falla nel sistema} sta nella possibilità di \hl{continuare ad accedere a file anche dopo che sono cambiati i privilegi}, dato che lasciando aperta la sessione del file non saremo soggetti ai nuovi privilegi.

Questa chiamata è \hl{interessante per le Thread} che vogliono lavorare in un loro ambiente.


% Open flags
\subsection{Open flags}

Abbiamo un certo numero di \hl{flag standard} dichiarate dall'SUSv3, il resto possono essere a discrezione dei sistemi UNIX.

Le flags più usate sono:

\begin{itemize}
	\item \hl{O\_DIRECTORY}: \textbf{limita la chiamata} open ad una directory specifica

	\item \hl{O\_CREAT}: flag per dire che si vuole \textbf{creare un file}

	\item \hl{O\_TRUNC}: se vuoi creare un file nuovo ed ne esiste già uno, il \textbf{vecchio viene azzerato}

	\item \hl{O\_EXCL}: se il file già esiste fa \textbf{fallire la chiamata}
\end{itemize}


% Builtin umask
\subsection{Builtin umask}

È un \hl{valore presente in ogni processo} ed ereditato dal parent ma il child può comunque modificarla. Il valore restituito è un numero ottale (inizia con 0):

\begin{lstlisting}
$ umask
0022

$ ll file
-rw-r--r-- 1 docente staff 0 14 Ott 09:02 file
\end{lstlisting}

quindi la umask \hl{taglia i permessi dei file creati da quel processo}. Quindi, in questo caso, un 666 diventa 644.


% Chiamata lseek()
\subsection{Chiamata lseek()}

Per un file appena creato la sua "current position" si trova all'inizio del file, ci si \hl{potra' muovere nel file} tramite lseek(). Gli argomenti sono:

\begin{enumerate}
	\item \hl{file descriptor}
	
	\item \hl{offset}: per dire \textbf{dove ci si vuole spostare}
	
	\item \hl{whence}: indica \textbf{da quale punto} si deve applicare l'offset:
	
		\begin{itemize}
			\item SEEK\_SET: valore preciso da dove partire
			
			\item SEEK\_CUR: presa la current position inserire un \textbf{gap e poi scrivere} (può essere negativo)
			
			\item SEEK\_END: gap dal quale inserire \textbf{rispetto alla fine} del file. Se negativo scrivo prima, se positivo posso lasciare un \textbf{buco di byte} e poi scrivere. Nei nuovi sistemi i blocchi vuoti vengono allocati.
		\end{itemize}
	
	
\end{enumerate}

Un esempio di buco in un file dato da un numero positivo con SEEK\_END:

\begin{lstlisting}
#include "apue.h"
#include <fcntl.h>

char	buf1[] = "abcdefgh";
char	buf2[] = "ABCDEFGH";

int
main(void)
{
	int		fd;

	if ((fd = creat("file.hole", FILE_MODE)) < 0)
		err_sys("creat error");

	if (write(fd, buf1, 10) != 10)
		err_sys("buf1 write error");
	/* offset now = 10 */

	if (lseek(fd, 16384, SEEK_SET) == -1)
		err_sys("lseek error");
	/* offset now = 16384 */

	if (write(fd, buf2, 10) != 10)
		err_sys("buf2 write error");
	/* offset now = 16394 */

	exit(0);
}	
\end{lstlisting}

avremo:

\begin{lstlisting}
$ xxd file.hole
00000000: 6162 6364 6566 0000    abcdefgh........
00000010: 0000 0000 0000 0000    ................
00000020: 0000 0000 0000 0000    ................
00000030: 0000 0000 0000 0000    ................
00000040: 0000 0000 0000 0000    ................
00000050: 0000 0000 0000 0000    ................
00000060: 0000 0000 0000 0000    ................
00000070: 4142 4344 4546 4748    ABCDEFGH........
\end{lstlisting}

abbiamo che la memoria sul disco è:

\begin{lstlisting}
$ du -h file.hole 
1.6M	file.hole
\end{lstlisting}

invece la size del file è:

\begin{lstlisting}
$ stat -x file.hole 
  File: "file.hole"
  Size: 1638410      FileType: Regular File
  Mode: (0644/-rw-r--r--)         Uid: (  501/    matt)  Gid: (   20/   staff)
Device: 1,16   Inode: 27657406    Links: 1
Access: Fri Oct 14 09:59:17 2022
Modify: Fri Oct 14 09:57:59 2022
Change: Fri Oct 14 09:57:59 2022
 Birth: Fri Oct 14 09:47:24 2022
\end{lstlisting}

Possiamo avere dei \hl{file descriptor seekble} se il file è regolare o meno:

\begin{lstlisting}
#include "apue.h"

int
main(void)
{
	if (lseek(STDIN_FILENO, 0, SEEK_CUR) == -1)
		printf("cannot seek\n");
	else
		printf("seek OK\n");
	exit(0);
}
\end{lstlisting}






ci sono più casi in cui il numero di byte letto è minore di quello chiesto:
1. possiamo avere un valore di ritorno di 50 se chiedo di leggere 100 perchè ci sono solo 50 byte
2. quando legge da un terminale: la read ritorna quando dai invio
3. quando legge da una rete: puoi leggere 100 byte ma se ne leggi 10 puoi gestire tu cosa fare, in genere se non arriva nulla la read rimane in attesa e non gli arrivano byte rimane appesa sennò se sono arrivati rimane appesa e poi interrompe quando non sente più nulla
4. quando legge da una pipe: se non arriva nulla rimane appesa, se arriva qualcosa interrompe e restituisce quello che ha letto
5. quando interrotta da un segnale e alcuni dati sono stati letti gli restituisce
