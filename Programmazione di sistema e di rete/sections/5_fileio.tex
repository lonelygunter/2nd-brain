\newpage
\section{File I/O}


% Introduzione
\subsection{Chiamata open}

I file I/O sono le \hl{funzioni che gestisce buffered I/O} ed in contrapposizione da quelle della librerira "stdlib". La chiamata open() fa parte di queste funzioni, i suoi argomenti sono:

\begin{itemize}
	\item \hl{arg}: path assoluto o relativo
	\item \hl{flag}: bit che indica l'\textbf{attivazione di alcune modalita'}. Si avrà allora a \textbf{settare il bit della flag a 1}:
	\item \hl{mode}: serve a dare i \textbf{privilegi con cui i file deve essere creato} (\textbf{da usare solo nella creazione del file})
\begin{lstlisting}
open(file, O_RDWR | O_APPEND | O_CREAT | O_TRUNC, file_mode)
\end{lstlisting}

		avremo allora: $11000001010$

		con O\_RDWR: 2, O\_APPEND: 8, O\_CREAT: 512, O\_TRUNC: 1024
		
		
\end{itemize}

Appena \hl{aperto il file questo avra' la "current position" a 0}, cioè ad inizio file. Iniziando a scrivere avremo che alla prima lettura la nostra current position si sarà spostata fino a dopo abbiamo finito di scrivere.

Per quanto riguarda \hl{read e write i bit delle flag} abbiamo un modo "scomodo":

\begin{lstlisting}
#define O_RDONLY        0x0000          /* open for reading only */
#define O_WRONLY        0x0001          /* open for writing only */
#define O_RDWR          0x0002          /* open for reading and writing */
#define O_ACCMODE       0x0003          /* mask for above modes */
\end{lstlisting}

sono dette quindi \hl{maschere} per leggere o scrivere.

Una variante e' \hl{openat()} che prende il file descriptor (passato dalla open() sulla directory) di una directory per passare il path relativo a quella directory. Abbiamo quindi la \hl{possibilita' di accedere a delle directory anceh senza avere i privilegi}. ???

il permesso di esecuzione delle directory serve a cercare un nome in una directory. se il permesso è disattivato non si riesce ad arrivare alla foglia, se invece apri una directory il sistema sa già a quale inod andare dato che si salva quello al posto di tutto il path. quindi fai diventare relativi i privilegi per quella directory. 

questa chiamata è interesante per quando le thread vogliono lavorarein un loro ambiente.

alla openat è associata una flag alla firectory aperta dalla open, allora usiamo la flag O\_DIRECTORY. nelle flag vediamo la differnza tra UNIX e gli standard dato che ce ne sono un certo numero di base e poi ogni UNIX ne agiunge altri. Gli standard gli troviamo nel manuale del SUSv3 e SUSv4.

O\_CREATE: flag per dire che si vuole creare un file. una trappola che c'è è la builtin "umask" usata per dare dei permessi di base. questa umask è presente in ogni processo e la eradita dal padre (ma può comunque modificarla). ci restituisce un numero ottale (perche inizia xon 0) e dice di togliere la scrittura ai gruppi

\begin{lstlisting}
$ umask
0022

$ ll file
-rw-r--r-- 1 docente staff 0 14 Ott 09:02 file
\end{lstlisting}

quindi la umask taglia i permessi dei file. quidndi se diamo un 666 nella creazione di un file con open ci ritroveremo 644.

altra trappola: se creo un file in sola scrittura e lettura ecc, potremo usare una chiamata per tolgiere dei flag in corsa. 


un altra trappola: la cosa strana è che se apri un file in rw e ottieni i privilegi, se i privilegi vengono cambiati dalla linea di comando togliendo w se vado a scrivere in quel file perchè aperto con la open in precedenza, quel file comunque puoi continuare a scriverlo dato che il permesso non viene revocato


O\_TRUNC: nella cfreazione dell file se il file esiste ed è aprto per rw viene azzerato il file (se vuoi aprire un file nuovo ed essite già il veccjhio viene azzerato)

O\_EXCL : nella creazione del file se in file già esiste fa fallire la chiamata. qundo si fa una read potrebbe essere appesa per giorni, ma se il file viene aperto con questo file, se non c'è nula da leggere o scrivere ritorna e non le lascia appese

chaiamata lseek: in un dato momento se hai un file descrptior sta in un certo punto del file (se non lo hai toccato stai all'inizio). lseek sui file già aperti permette di spostare la "current position" 

1 arg: file descriptor
2. offset per dire dove ci si vuole spostare
3. whence: ("da dove") puo essere: SEEK\_SET valore preciso di dove andare. SEEK\_CUR può ssere neagativo ed indica il gap dopo il quale nadare cioe di quanto sposarsi, SEEK\_END valore rispetto alla file sarà negativo ma se metto valore positivo creun un uco dato che salto alcuni blocchi. nell'inod viene indicato il file buchi compresi, l'inod ricrodiamo che ha 256 byte dove un pò sono usati per i metadati e nel resto abbiamo dei puntatori a dei blocchi che sono a loro volta blocchi di puntatori ecc quidni non c'è il concetto di buco coi blocchi perchè semplicemente ci son u può di blochci da una parte e un pò dall'altra 

Un esempio di buco lo creiamo:

\begin{lstlisting}
#include "apue.h"
#include <fcntl.h>

char	buf1[] = "abcdefghij";
char	buf2[] = "ABCDEFGHIJ";

int
main(void)
{
	int		fd;

	if ((fd = creat("file.hole", FILE_MODE)) < 0)
		err_sys("creat error");

	if (write(fd, buf1, 10) != 10)
		err_sys("buf1 write error");
	/* offset now = 10 */

	if (lseek(fd, 16384, SEEK_SET) == -1)
		err_sys("lseek error");
	/* offset now = 16384 */

	if (write(fd, buf2, 10) != 10)
		err_sys("buf2 write error");
	/* offset now = 16394 */

	exit(0);
}	
\end{lstlisting}

avremo:

\begin{lstlisting}
$ xxd file.hole
00000000: 6162 6364 6566 6768 696a 0000 0000 0000  abcdefghij......
00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000020: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000030: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000040: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000050: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000060: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000070: 4142 4344 4546 4748 494a                 ABCDEFGHIJ
\end{lstlisting}

abbiamo che la memoria effettiva sul disco è:

\begin{lstlisting}
$ du file.hole
3208	file.hole
\end{lstlisting}

invece la size del file viene dichiarata:

\begin{lstlisting}
$ stat -x file.hole 
  File: "file.hole"
  Size: 1638410      FileType: Regular File
  Mode: (0644/-rw-r--r--)         Uid: (  501/    matt)  Gid: (   20/   staff)
Device: 1,16   Inode: 27657406    Links: 1
Access: Fri Oct 14 09:59:17 2022
Modify: Fri Oct 14 09:57:59 2022
Change: Fri Oct 14 09:57:59 2022
 Birth: Fri Oct 14 09:47:24 2022
\end{lstlisting}




esistono dei file descriptor seekble e non che cerca di capire se è un file regolare o meno:

\begin{lstlisting}
#include "apue.h"

int
main(void)
{
	if (lseek(STDIN_FILENO, 0, SEEK_CUR) == -1)
		printf("cannot seek\n");
	else
		printf("seek OK\n");
	exit(0);
}
\end{lstlisting}




ci sono piu casi in cui il numero di byte letto è minore di quello chiesto:
1. possiamo avere un valore di ritorno di 50 se chiedo di leggere 100 perchè ci sono solo 50 byte
2. quando legge da un terminale: la read ritorna quando dai invio
3. quando legge da una rete: puoi leggere 100 byte ma se ne leggi 10 puoi gestire tu cosa fare, in genere se non arriva nulla la read rimane in attesa e non gli arrivano byte rimane appesa sennò se son oarrivati rimane appesa e poi interrompe quando non sente più nulla
4. quando legge da una pipe: se non arriva nulla rimane appesa, se arriva qualcosa interrompe e restituisce quello che ha letto
5. quando interrotta da un segnale e alcuni dati sono stati letti gli restituisce
