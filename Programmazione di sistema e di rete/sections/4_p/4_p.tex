
\section{ - 30.09.22}

make file: formato da rule per poter arrivare al target 

a volte abbiamo uno script configure che precede make install dove install è il target. 

il make file si aggiorna tramite l'ultima modifica del file seguendo pero la gerarchia

molto utile il target clean per togliere tutti i file .o che sono inutili dopo la compilazione. sono detti phony perchè target fasulli dato che non sono file ma sole parole

ci sono delle scorciatoie :
\$@ per riferirsi il target
\$? tutti i prerequisiti più recenti del target
\$^ tutti i prerequisiti del target
https://www.gnu.org/software/make/manual/make.html#Automatic-Variables


quando sis scrve make si va a guadare se in quella direcotry di trova un a file chiamato Makefile. quidni se c'e1 viene eseguito

abbimao:

DIRS = lib intro sockets advio daemons datafiles db environ \
	fileio filedir ipc1 ipc2 proc pty relation signals standards \
	stdio termios threadctl threads printer exercises

all:
	for i in $(DIRS); do \
		(cd $$i && echo "making $$i" && $(MAKE) ) || exit 1; \
	done

clean:
	for i in $(DIRS); do \
		(cd $$i && echo "cleaning $$i" && $(MAKE) clean) || exit 1; \
	done
	
	
a dire si sostituisce quelloa destra dell =

all:
manda un comando in subshell
\$\$i sarebbe un riferimento alla varibile i ma con un escape che si fa con \$ in Makefile

\$(MAKE) macro predefinita doce dico che voglio usa la macro anche se sembra essere definita. 

se le regole sono a più righe, ognuna deve iniziare col tabulatore

noi abbimamo pero fartto un cd e poi chiamato \$(MAKE) allora supponiamo che in ogni direcotry ha il suo make file

in apue.3e abbiamo un make file:

root abbiamo la cartella precedente alla cwd
platform assumera in valore del OS macos o linux
e poi si include ../Make.defines.macos

abbiamo una altra macro PROGS che elenca.i programmi che vorremmo costruire

si può usare \% per dire che unado c'e quancosa ed il prerequisnito è .c, per esempio, allra esegui la rule. indica un valore qualsisasi come una varibile. una regola implicigta per ogni file c


altra macro \$(CC) che indica i lcompilatore dove cc è un link simbolico a clang

\$(CFLAGS) indica una macro predefinite vuote dato che se le riempi danno quello che scrivi ma eseistono anche perche ci sono delle regole rpedefinite usate da delle macro

in ../Make.defines.macos ho:

\begin{lstlisting}
# Common make definitions, customized for each platform

# Definitions required in all program directories to compile and link
# C programs using gcc.

CC=gcc
COMPILE.c=$(CC) $(CFLAGS) $(CPPFLAGS) -c
LINK.c=$(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS)
LDFLAGS=
LDDIR=-L$(ROOT)/lib
LDLIBS=$(LDDIR) -lapue $(EXTRALIBS)
CFLAGS=-ansi -I$(ROOT)/include -Wall -DMACOS -D_DARWIN_C_SOURCE $(EXTRA)
RANLIB=ranlib
AR=ar
AWK=awk
LIBAPUE=$(ROOT)/lib/libapue.a

# Common temp files to delete from each directory.
TEMPFILES=core core.* *.o temp.* *.out
\end{lstlisting}


impostante capire che Make ha delle definizoni di fedault visibili in make -p. così facendo tutti i file passati in all si andrà a vedere se sono .c e se lo sono utilizza la rule di \% se questa rule non ci fosse userebbe la definizione di default


se modifichiamo un solo file posisamo fare un compile.sh al quale pasimao come argomento il nome del file .c e al suoi interno mettiamo ilcomando di gcc di compilaizone. questo al posto di usare make


gcc -H # To see the hierarchy of the include files
gcc -E file.c # To see the effect of preprocessor directives
