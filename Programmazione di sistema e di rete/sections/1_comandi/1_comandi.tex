\newpage
\section{Comandi utili}

% find
\subsection{find: trovare tutti i file eseguibili}
	
\begin{lstlisting}
$ find . -type f -perm -0100
./standards/makeopt.awk
./standards/makeconf.awk
./proc/awkexample
./systype.sh
./advio/fixup.awk
\end{lstlisting}


\subsection{find: trovare file di intestazione del mac come stdio.h}

\begin{lstlisting}
$ find /Applications/Xcode.app/ -name stdio.h 2>/dev/null
\end{lstlisting}


% ldd
\subsection{lld: per capire che librerie usa il codice}

\begin{lstlisting}
$ ldd [nomevodice]
\end{lstlisting}


% gcc
\subsection{gcc: per vedere tutta la gerarchia di file in una libreria}

\begin{lstlisting}
$ gcc -H lib.a
\end{lstlisting}


\subsection{gcc: per vedere il codice con tutti i file importati}

\begin{lstlisting}
$ gcc -E file.c
\end{lstlisting}

\subsection{gcc -g: debugging debole}

\begin{lstlisting}
$ gcc -g -ansi -I../include -Wall -DMACOS -D_DARWIN_C_SOURCE  ls1.c -o ls1  -L../lib -lapue
\end{lstlisting}


\subsection{gcc -ggbd: debugging forte}

\begin{lstlisting}
$ gcc -ggbd -ansi -I../include -Wall -DMACOS -D_DARWIN_C_SOURCE  ls1.c -o ls1  -L../lib -lapue
\end{lstlisting}

con opzioni (ggbd per Linux e lldb per MacOS):
\begin{itemize}
    \item s: per fare stepping
    \item n: per fare stepping over delle funzioni
    \item c: per continuare con il run
    \item b [\# linea]: per impostare un breakpoint
    \item p [nome variabile]: per stampare le variabili
        possiamo avere la possibilitÃ  di vedere la memoria di una variabile: 

\begin{lstlisting}
(lldb) p &fd1
\end{lstlisting}

        notare che \hl{andando a guardarle possiamo capire dove si trova lo stack}. 

        Per capire fin dove arriva la "punta" dello stack possiamo usare:

\begin{lstlisting}
(lldb)register read
\end{lstlisting}

        per poter leggere tutti i registri. Per leggere la "punta" usiamo come indirizzo quello dello stack pointer $\$sp$:

\begin{lstlisting}
(lldb) memory read --size 4 --fromat x --count 160 $sp
\end{lstlisting}

        rax registrodove c'e1 il numero della system call
        rsp: stack frame pointer

        rbx, rcx, rdx, rdi, rsi: paramentri di funzioni e system call 

        rbp: base dello stack frame

        rsp e rbp salgono quando lo stack frame viene rilasciato


        rip: registro di instruction pointer e dice quale istruzione sara1 eseguita e sara1 un valore basso se punta ad un istruzione che sta nel text invece altro se si trova in una libreria


        (lldb) disassemble: fa vedere il codice eseguibile in assembly delle funzoine che sto eseguendo. indica con -> la prossima istruzione che sta per essere eseguita


        sara1 possibile eseguire le chiamata in codice assembly una alla volta tramite:

        (lldb) register read [nome registro]

        per eseguire una sola istruzione usiamo 

        (lldb) si

    \item bt: per vedere lo stato dello stack
    \item l: (list) per vedere il codice sorgente
    \item r [args]: (run) per dare gli argomenti e runnare
\end{itemize}

per vedere il numero dell'indirizzo come decimale e quindi poi KB, MB, GB o TB...:
\begin{lstlisting}
$ echo $((0x000000016fdffa1e))
6171916830
\end{lstlisting}

per vedere il contenuto in char (c), decimale (d), esadeciamle (x) di un indirizzo di memoria:
\begin{lstlisting}
(lldb) memory read --size 1 -l4 --format c --count 10 0x000000016fdffa1e
0x16fdffa1e: dd2.
0x16fdffa22: c\0ch
0x16fdffa26: un
\end{lstlisting}


% xattr
\subsection{xattr: usato per i file che entrano in quarantena su MacOS}

\begin{lstlisting}
$ xattr -d (delete) com.apple.quarantine [path sh]
\end{lstlisting}


% apropos
\subsection{apropos: per fare un a grep sulla riga name nelle pagine di manuale}

\begin{lstlisting}
$ apropos acl
\end{lstlisting}



\section{Variabili di sistema definite in .bashrc}

% INC
\subsection{INC}

\begin{lstlisting}
INC="/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/"
\end{lstlisting}

