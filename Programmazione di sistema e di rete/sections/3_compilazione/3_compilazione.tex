\section{Compilazione - 28.09.22}

% Direttive di preprocessore
\subsection{direttive di preprocessore}
Sono delle \hl{indicazioni date a gcc prima di iniziare la compilazione}.

Iniziano tutte con '#':
\begin{itemize}
	\item \textbf{#include}: serve ad \textbf{includere delle librerie} di sistema ($<$lib.h$>$) oppure di librerie fatte da noi e non in directory standard ("lib.h")
	\item \textbf{#define}:
		\begin{itemize}
			\item permette di \textbf{creare delle "macro"}, che vanno a sostituire una stringa con un'altra (es: #define BUFLEN), può capitare che debbano essere definite delle macro prima che si compili il programma, in questi casi si usa scrivere es: '-DMACOS'
			\item permette di \textbf{creare delle "function like macro"} (es: #define ABSOLUTE\_VALUE(x) (((x$<$0)?-(x):(x))  
		\end{itemize}
		
	\item \textbf{#ifdef, #ifndef, #endif}: usata per far accadere qualcosa nel caso un macro sia stata definita
\begin{lstlisting}
#ifdef VAR
print("hello");
#endif
\end{lstlisting}

\end{itemize} 

\hl{Per evitare che più file includano lo stesso si usano degli #ifndef} in tutto il codice, in modo da evitare doppie definizioni.


% Librerie
\subsection{Librerie}

Durante la fase di compilazione creiamo dei file oggetto (.o) per ogni file in cui è scritta la descrizione delle funzioni di libreria (.c)

\begin{lstlisting}
gcc -c bill.c
\end{lstlisting}

Si andrà poi a creare il \hl{prototipo della funzione (.h)}.

In fine \hl{tramite il linker si andranno ad unire tutti i file per crearne uno unico} con tutte le definizioni delle funzioni incluse nelle librerie, di sistema e non, importate. Si vanno quindi a \hl{sciogliere tutti i riferimenti incrociati}.

\begin{lstlisting}
	gcc -o program program.o bill.o
\end{lstlisting}

Per quanto riguarda le \hl{funzioni di sistema} NON abbiamo il file sorgente ma abbiamo direttamente l'eseguibile. In compenso abbiamo un \hl{file di libreria}, cioè un insieme di file oggetto linkati in un unico file, dove c'è il codice oggetto di tutte le funzioni.

Abbiamo \textbf{2 tipi di librerie}:
\begin{itemize}
	\item \hl{statiche}: è una \textbf{collezione di file oggetto} che hanno il codice compilato delle funzioni e che verranno \textbf{linkati al momento della compilazione}. Il programma che si crea sarà possibile essere eseguito solo sullo stesso OS.
		
		Il \textbf{problema si ha nell'aggiornamento delle librerie al momento della scoperta di un bug}. Una volta coretto servirà ricevere la versione corretta per poter aggiornare il programma.
		
	\item \hl{dynamic}: ricordano il concetto di plug-in, quindi \textbf{viene invocato a runtime e caricato in memoria} (es: aggiornamenti dei OS). \textbf{L'eseguibile non viene toccato la correzione avviene solo nella libreria}.
	
		Il requisito maggiore è che chi si passa il codice debba avere lo stesso OS dell'altro utente. Notare che \textbf{non cambia il prototipo} dato che sennò bisognerà ricompilare l'intero programma.
\end{itemize}


In generale le \hl{librerie statiche sono molto pericolose} infatti alcuni OS le aboliscono \hl{per le questioni di sistema}. Su linux si ha come libreria statica 'lib.c' che è la libreria con le funzioni più usate in c. Per macos è stata abolita.

Per compilare con la versione dinamica non servono opzioni, per la statica si usa:

\begin{lstlisting}
gcc -static
\end{lstlisting}


% Creazione librerie
\subsection{Creazione librerie}

Per costruire una \hl{libreria statica per MacOS}:

\begin{enumerate}
	\item costruiamo il \textbf{file oggetto}:

\begin{lstlisting}
gcc -c libprova.c
\end{lstlisting}
		
	\item costruiamo la \textbf{libreria} (con ar=archive, c=create se lib.a non esiste):

\begin{lstlisting}
ar rcs libprova.a libprova.o
\end{lstlisting}
			
	\item costruire il \textbf{codice} che usa la libreria (con -Wall=verbose warning, -g=debugging, -c=create del file):

\begin{lstlisting}
gcc -Wall -g -c useprova.c
\end{lstlisting}
	
	\item \textbf{linker} per risolve le chiamate incrociate (con -L.=dove prendere la libreira, -l[nomelib]=usare la libreria):

\begin{lstlisting}
gcc -g -o useprova useprova.o -L. -lprova 
\end{lstlisting}

\end{enumerate}

Per capire che librerie usa il codice si usa:

\begin{lstlisting}
otool -L [nomecodice]
\end{lstlisting}


Per costruire una \hl{libreria statica per Linux}:

\begin{enumerate}
	\item costruiamo il \textbf{file oggetto}:

\begin{lstlisting}
gcc -fPIC -Wall -g -c libprova.c
\end{lstlisting}

	\item costruiamo la \textbf{libreria}: gcc -g -shared -Wl,-soname,libprova.so.0 -o libprova.so.0.0 libprova.o -lc (indica che usa libc)
	\item costruire del \textbf{link simbolico per aggiornare le librerie} senza aggiornare gli eseguibili. quindi si puo usare sempre lo setsso nome del programa ma saprà lui grazie ai link simboliic lo porterrano al file con la versione giusta: ln -sf libprova.so.0.0 libprova.so.0 
	\item \textbf{linker} per risolve le chiamate: ln -sf libprova.so.0 libprova.so
\end{enumerate}
1. 


Per capire che librerie usa il codice si usa:

\begin{lstlisting}
ldd [nomevodice]
\end{lstlisting}

per defaoult avremko una compilazione dinamica, in caso constrario possiamo aggiungere -static

su linux allora creeremp una variabile di ambiente imposta all'eseguibile (dato che sennò non sa dove trovarla infatti fa -$>$ not found), questa variabile è LD_LIBRARY_PATH=`pwd` ldd useprova quindi s sesite una  libreira sattica lui prenderà la dinamica e dovremo specificare la variabile di ambiente. tipicamente la libreria viene disrtibuita nelle direcotry di sistema andandola ad "installare"

MACOS:
la libreria dinamica è: gcc -dynamiclib libprova.c -o libprova.dylib # Builds the shared library

eseguendo il programam trova la libreira dato che va a controllare nella directory corrente e quindi non serve creare la variabile di ambiente come si linux

i file di intestazione del mac come stdio.h per cercarla uso: find /Applications/Xcode.app/ -name stdio.h 2$>$/dev/null

MAKE:
andiamo a guardar cosa contine make file per carpire cosa fa:




DIRS = lib intro sockets advio daemons datafiles db environ \
	fileio filedir ipc1 ipc2 proc pty relation signals standards \
	stdio termios threadctl threads printer exercises

all:
	for i in $(DIRS); do \
		(cd $$i && echo "making $$i" && $(MAKE) ) || exit 1; \
	done

clean:
	for i in $(DIRS); do \
		(cd $$i && echo "cleaning $$i" && $(MAKE) clean) || exit 1; \
	done




DIRS è tutta quella cosa

i make file hanno delle loro regole per fare delle cose. per esempio all è detto target, cioè la cosa che vuoi fare qundi sarebbe make all. che è la cosa fi defalult dato che è il primo allora scrivendo solo make lo avvieamo. a volte possono essere dei prerequisiti che posson essere a lor volta degli altri target. la figa delle regole è quella che viene dopo i : che vengono però dopo i prerequisiti ed indica che poer fare il target bisogna usare queste regole. 
i vincoli sintattici sono il tabulatore e poi si mettono i programmi da shell.