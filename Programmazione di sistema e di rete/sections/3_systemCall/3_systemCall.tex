\newpage
\section{System call}

% Funzioni e system call
\subsection{Funzioni e system call}

Se prendiamo un funzionamento più semplice del comando "ls" potrebbe essere:

\begin{lstlisting}
#include "apue.h"
#include <dirent.h>

int
main(int argc, char *argv[])
{
	DIR				*dp;
	struct dirent	*dirp;

	if (argc != 2)
		err_quit("usage: ls1 directory_name");

	if ((dp = opendir(argv[1])) == NULL)
		err_sys("can't open %s", argv[1]);
	while ((dirp = readdir(dp)) != NULL)
		printf("%s\n", dirp->d_name);

	closedir(dp);
	exit(0);
}
\end{lstlisting}


dove abbiamo che:

\begin{itemize}
	\item \hl{DIR}: struttura dati
	\item \hl{struct dirent}: \textbf{tipo struttura} che contiene al suo interno diversi tipi di variabili. 
	
		Per capire se è una funzione di sistema lanciamo:
		
\begin{lstlisting}
$ grep -rw "struct dirent" $INC

/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include//sys/dirent.h:struct dirent {
\end{lstlisting}
		
\begin{lstlisting}
#ifndef _SYS_DIRENT_H
#define _SYS_DIRENT_H

#include <sys/_types.h>
#include <sys/cdefs.h>

#include <sys/_types/_ino_t.h>


#define __DARWIN_MAXNAMLEN      255

#pragma pack(4)

#if !__DARWIN_64_BIT_INO_T
struct dirent {
	ino_t d_ino;                    /* file number of entry */
	__uint16_t d_reclen;            /* length of this record */
	__uint8_t  d_type;              /* file type, see below */
	__uint8_t  d_namlen;            /* length of string in d_name */
	char d_name[__DARWIN_MAXNAMLEN + 1];    /* name must be no longer than this */
};
#endif /* !__DARWIN_64_BIT_INO_T */

#pragma pack()

#define __DARWIN_MAXPATHLEN     1024

#define __DARWIN_STRUCT_DIRENTRY { \
	__uint64_t  d_ino;      /* file number of entry */ \
	__uint64_t  d_seekoff;  /* seek offset (optional, used by servers) */ \
	__uint16_t  d_reclen;   /* length of this record */ \
	__uint16_t  d_namlen;   /* length of string in d_name */ \
	__uint8_t   d_type;     /* file type, see below */ \
	char      d_name[__DARWIN_MAXPATHLEN]; /* entry name (up to MAXPATHLEN bytes) */ \
}

#if __DARWIN_64_BIT_INO_T
struct dirent __DARWIN_STRUCT_DIRENTRY;
#endif /* __DARWIN_64_BIT_INO_T */



#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
#define d_fileno        d_ino           /* backward compatibility */
#define MAXNAMLEN       __DARWIN_MAXNAMLEN
/*
 * File types
 */
#define DT_UNKNOWN       0
#define DT_FIFO          1
#define DT_CHR           2
#define DT_DIR           4
#define DT_BLK           6
#define DT_REG           8
#define DT_LNK          10
#define DT_SOCK         12
#define DT_WHT          14

/*
 * Convert between stat structure types and directory types.
 */
#define IFTODT(mode)    (((mode) & 0170000) >> 12)
#define DTTOIF(dirtype) ((dirtype) << 12)
#endif


#endif /* _SYS_DIRENT_H  */
\end{lstlisting}

		dove vediamo che se la variabile "\_\_DARWIN\_64\_BIT\_INO\_T" è stata definita avremo che la struttura di struct dirent è:
		
\begin{lstlisting}
#define __DARWIN_STRUCT_DIRENTRY { \
	__uint64_t  d_ino;      /* file number of entry */ \
	__uint64_t  d_seekoff;  /* seek offset (optional, used by servers) */ \
	__uint16_t  d_reclen;   /* length of this record */ \
	__uint16_t  d_namlen;   /* length of string in d_name */ \
	__uint8_t   d_type;     /* file type, see below */ \
	char      d_name[__DARWIN_MAXPATHLEN]; /* entry name (up to MAXPATHLEN bytes) */ \
}

#if __DARWIN_64_BIT_INO_T
struct dirent __DARWIN_STRUCT_DIRENTRY;
#endif /* __DARWIN_64_BIT_INO_T */
\end{lstlisting}

		
	\item \hl{if}: esegue un controllo sugli args. Notiamo che "err\_quit" non è una funzione di sistema da:
	
\begin{lstlisting}
$ grep -rw "err_quit" $INC
\end{lstlisting}

		infatti non restituisce nulla. Deve allora essere una funzione di libreria create da noi quindi non presente nella directory standard.
		
		La funzione andrà a dare un messaggio di errore e poi esce dal programma.
		
		
	\item \hl{opendir}: serve ad aprire una directory andandola a caricare nella RAM. 
	
	\item \hl{while}: leggiamo la directory e la inseriamo nella struttura che poi sarà richiamata tramite:
	
\begin{lstlisting}
dirp->d_name
\end{lstlisting}

		dove "d\_name" è il nome dello slot in cui è contenuto il nome del file.
		
		
	\item \hl{exit}: restituisce l'exit code del programma
	
\end{itemize}


% Capire se una funzione è una system call
\subsection{Capire se una funzione è una system call}

Andiamo a \hl{vedere se e' una funzione o una system call tramite "man"}, lo si capisce tramite la dicitura in alto alla pagina del manuale:

	\begin{itemize}
		\item \textbf{Library Functions} Manual
		\item \textbf{System Calls} Manual
	\end{itemize}

Abbiamo anche \hl{esempi piu' particolari}, come fork, dove è indicata come system call ma in realtà le richiama ma in prima persona.


Potremo trovare i simboli di una libreria tramite:

\begin{lstlisting}
$ nm lib.a
\end{lstlisting}

che ci fa vedere, per ogni file oggetto, i simboli associati per ogni funzione.

Le system call le troveremo in "\$INC/sys/syscall.h"


% Numeri dei file descriptor
\subsection{Numeri dei file descriptor}

Prendiamo un esempio semplificato del comando "cat":

\begin{lstlisting}
#include "apue.h"

#define	BUFFSIZE	4096

int
main(void)
{
	int		n;
	char	buf[BUFFSIZE];

	while ((n = read(STDIN_FILENO, buf, BUFFSIZE)) > 0)
		if (write(STDOUT_FILENO, buf, n) != n)
			err_sys("write error");

	if (n < 0)
		err_sys("read error");

	exit(0);
}
\end{lstlisting}

\hl{ogni processo ha 3 file descriptor usati 0, 1, 2}.

\begin{itemize}
	\item \hl{BUFFSIZE}: macro di preprocessore
	\item \hl{read}: \textbf{system call} con parametri: 
	
		\begin{itemize}
			\item \textbf{STDIN\_FILENO}: file descriptor per dire da quale "numero di deve leggere" si vuole leggere. Cioè per leggere dal file indicato nello standard input
			\item \textbf{buf}: indirizzo dell'\textbf{inizio dell'array}
			\item \textbf{BUFFSIZE}: quando deve leggere
		\end{itemize}
		
		\hl{Restituisce il numero di char che ha letto}, dato che potrebbe leggere meno byte di quelli richiesti nel caso in cui il file ne contenga di meno. Ad ogni sua iterazione \hl{si ricorda la "posizione nel file"} che gli permette di non leggere sempre i primi n byte ma di rincominciare da dove ha lasciato.
	
	\item \hl{write}: richiede gli stessi valori di read tranne per \textbf{STDOUT\_FILENO} e \textbf{ritorna il numero byte effettivamente letti}
	\item 
\end{itemize}


per capire \hl{quanto vale STDIN\_FILENO}:


\begin{lstlisting}
$ grep -rw "STDIN_FILENO" $INC

/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include//unistd.h:#define	 STDIN_FILENO	0	/* standard input file descriptor */
/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include//asl.h: * asl_log_descriptor(c, m, ASL_LEVEL_NOTICE, STDIN_FILENO, ASL_LOG_DESCRIPTOR_READ);
\end{lstlisting}


Sappiamo che un processo per eseguire un programma, esegue prima una \hl{fork} e poi con \hl{exec} esegue il programma. Prima di eseguire la fork il \hl{child chiude il file 1} e quando fa una \hl{open}, la system call prenderà il file nel quale reindirizzare lo STDOUT e restituirà il numero 1.

Su questo sistema si base UINX infatti avviene anche con le pipe "|". Permette di creare programmi complessi unendo tanti piccoli programmi specializzati in un'unica funzione.

È molto importante capire che \hl{ i child ereditano i file descriptor dei parent} quindi non è necessario che il programma corrente faccia una open dei file descriptor.


% Meccanismi dei file
\subsection{Meccanismi dei file}

Un file è in insieme di meccanismi: 

\begin{itemize}
	\item \hl{apri}
	\item \hl{leggi}
	\item \hl{scrivi}
	\item \hl{chiudi}
\end{itemize}


Questi meccanismi sono applicabili a file, cartelle, stampanti ecc..., solo che per ogni "tipo" \hl{i 4 meccanismi si adeguano} a ciò che il caso particolare deve fare.


% Unbuffered I/O
\subsection{Unbuffered I/O}

Le system call rappresentano una barriera tra kernel e programmi, dove avremo rispettivamente \hl{due diverse modalita' di utilizzo}:

\begin{itemize}
	\item \textbf{kernel mode}: ha tutti i privilegi
	\item \textbf{user mode}: non può accedere a tutte le celle di memoria
\end{itemize}


Per \hl{ottimizzare la scrittura sulla memoria da parte del kernel si utilizza la libreria STDIOLIB} che incrementa le prestazioni dato che gestisce il passaggio di pacchetti con il kernel in modo da inviare dei pacchetti consistenti ogni tot e non piccoli pacchetti soni secondo. Per fare ciò usa un \hl{buffered i/o} che, una volta riempiti dei buffer, gli manda al kernel.


\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{unbuffio.jpeg}
\caption{Schema unbuffered I/O} 
\label{unbuffio}
\end{figure}


% Fork & Exec
\subsection{Fork \& Exec}

Prendiamo il codice di shell1.c che crea uno schell dal quale poter eseguire programmi:

\begin{lstlisting}
#include "apue.h"
#include <sys/wait.h>

int
main(void)
{
	char	buf[MAXLINE];	/* from apue.h */
	pid_t	pid;
	int		status;

	printf("%% ");	/* print prompt (printf requires %% to print %) */
	while (fgets(buf, MAXLINE, stdin) != NULL) {
		if (buf[strlen(buf) - 1] == '\n')
			buf[strlen(buf) - 1] = 0; /* replace newline with null */

		if ((pid = fork()) < 0) {
			err_sys("fork error");
		} else if (pid == 0) {		/* child */
			execlp(buf, buf, (char *)0);
			err_ret("couldn't execute: %s", buf);
			exit(127);
		}

		/* parent */
		if ((pid = waitpid(pid, &status, 0)) < 0)
			err_sys("waitpid error");
		printf("%% ");
	}
	exit(0);
}
\end{lstlisting}

avremo allora:

\begin{itemize}
	\item \hl{fgets}: funzione dello \textbf{stdoutput che legge la stringa} che dai prima di dare invio, ha come argomenti:
	
		\begin{itemize}
			\item \textbf{buf}: buffer nel quale mettere la stringa
		
			\item \textbf{MAXLINE}: proviene da una nostra libreria

\begin{lstlisting}
$ grep -rw "MAXLINE" include/
Binary file include//apue.h.gch matches
include//apue.h:#define	MAXLINE	4096			/* max line length */
\end{lstlisting}

			\item \textbf{stdin}: presente in stdiolib ed è una \textbf{struttura file che definisce uno standard input} tramite un puntatore ad un "file"
		\end{itemize}

	\item \hl{if 1}: permette di avere un null dove prima avevamo \textbackslash n
	
	\item \hl{if 2}: abbiamo una fork() che dopo che \hl{viene invocata ritorna 2 volte}, questo perché andrà a creare 2 bash identici con memorie uguali nei contenuti ma indipendenti, l'unico cambiamento è il pid. fork() andrà quindi a restituire 0 nel child e il pid del child al parent tramite getppid().

			Se pid $<$ 0 vorrà dire che la fork e fallita.
			Se pid = 0 vorrà dire che siamo nel child.
	
			Il che è molto importante dato che \hl{il codice verra' eseguito sia dal child che dal parent}, e sarà contenuto nella memora virtuale che hanno i programmi grande $2^{32}$ o $2^{64}$ in base all'OS.
	
			Appena viene eseguita l'\hl{exec, lo spazio di memoria viene azzerato} ma a discrezione del programma, vengono salvate alcune variabili di ambiente.


		\hl{execlp}: serve a far \textbf{eseguire un codice} (buf) del quale abbiamo il sorgente e l'eseguibile
	

		\hl{if 3}: serve a far andare aventi il parent.

		\hl{waitpid}: aspetta il child nel caso impieghi troppo tempo ad eseguire la sua azione, \textbf{tenendo appeso il prompt}. Con argomenti:

			\begin{itemize}
				\item \textbf{pid}: pid del child
				\item \textbf{\&status}: reindirizza l'exit code del child, quando finisce, nella variabile status
			\end{itemize}
			
\end{itemize}


\begin{figure}[H]
\centering
\includegraphics[scale=0.7]{fork.jpeg}
\caption{Esecuzione di fork ed exec} 
\label{fork}
\end{figure}


% Thread
\subsection{Thread}

Sono dei \hl{processi con lo stesso spazio di memoria del parent}. Per evitare che ogniuno scriva dove vuole, \hl{avviene una sincronizzazione tra le thread}. Questo metodo viene usato nelle macchine unicore per poter svolgere più operazione "contemporaneamente".

Tutto questo è \hl{orchestrato dal kernel} che gestisce il \hl{time shearing}.


% Gestione degli errori
\subsection{Gestione degli errori}

Per convenzione una funzione ritorna 0 se è andato tutto bene. Ci sono delle eccezioni, come la read, che ritorna il numero di byte letti.

Ogni valore possibile ritornato è specificato nel manuale:

\begin{lstlisting}
$ man 2 intro
...
1 EPERM Operation not permitted. An attempt was made to perform an operation limited to processes with appropriate privileges or to the owner of a file or other resources.

2 ENOENT No such file or directory. A component of a specified pathname did not exist, or the pathname was an empty string.
...
\end{lstlisting}


Per le \hl{system call}, quando avviene un errore, si \hl{avvalora la variabile "errno"} che può essere consultata in un programma con 

\begin{lstlisting}
extern int errno;
\end{lstlisting}


Con "errno" bisogna tenere in conto che:

\begin{enumerate}
	\item \hl{non viene svuotata quando passiamo l'errore}. Quindi per sapere quando è stato dato un errore bisogna andare a consultarla quando la system call viene invocata
	\item \hl{vale 0} se non usata
\end{enumerate}


Per la gestione degli errori useremo:

\begin{itemize}
	\item \hl{strerror}: restituisce la \textbf{stringa del valore} di errno
	\item \hl{perror}: legge errno e stampa un messaggio a piacere
\end{itemize}


\begin{lstlisting}
#include "apue.h"
#include <errno.h>

int
main(int argc, char *argv[])
{
	fprintf(stderr, "EACCES: %s\n", strerror(EACCES));
	errno = ENOENT;
	perror(argv[0]);
	exit(0);
}
\end{lstlisting}


dove:

\begin{itemize}
	\item \hl{fprinf}: stampa un errore allo standard specificato
\end{itemize}


% Keyword in C ed accessi a variabili
\subsection{Keyword in C ed accessi a variabili}

In C le variabili con la keyword const. 
veidmao lo scope delle varibili in C. se sono un porgramma ed entro in una funzione non vedo le variabili di altre funzioni ma solo quelle locali. se una fnzione vuole lavorare anche sul mondo esterno possiamo:

\begin{enumerate}
	\item attraverso il passaggio di variabili dai parametri
	\item vengono passati alla funzione gli indirizzi delle vafribili e quidni può modificarne il dato tramite la keyword *
	\item tramite variabili globali
\end{enumerate}

const insieme a * serve a far accedere alla variabile ma senza farci scrivere nulla. chi la fa stare ferma è il compilatore 

altra keyword: restrict

vuol dire che i puntatori non possono essere copiati in altre variabili. posso accedere al dato solo con la variabile con la keyword restrict dato che il compilatore può confondersi con la copia delle variabili. vinee applicato ai parametri


User ID: per linux si trova in 

\begin{lstlisting}
$ cat /etc/passwd | grep -w franco
\end{lstlisting}

oppure con 

\begin{lstlisting}
$ id
\end{lstlisting}

che contiene: ....


% Segnal e interupt
\subsection{Segnal e interupt}

vediamo shell2.c :

\begin{lstlisting}
#include "apue.h"
#include <sys/wait.h>

static void	sig_int(int);		/* our signal-catching function */

int
main(void)
{
	char	buf[MAXLINE];	/* from apue.h */
	pid_t	pid;
	int		status;

	if (signal(SIGINT, sig_int) == SIG_ERR)
		err_sys("signal error");

	printf("%% ");	/* print prompt (printf requires %% to print %) */
	while (fgets(buf, MAXLINE, stdin) != NULL) {
		if (buf[strlen(buf) - 1] == '\n')
			buf[strlen(buf) - 1] = 0; /* replace newline with null */

		if ((pid = fork()) < 0) {
			err_sys("fork error");
		} else if (pid == 0) {		/* child */
			execlp(buf, buf, (char *)0);
			err_ret("couldn't execute: %s", buf);
			exit(127);
		}

		/* parent */
		if ((pid = waitpid(pid, &status, 0)) < 0)
			err_sys("waitpid error");
		printf("%% ");
	}
	exit(0);
}

void
sig_int(int signo)
{
	printf("interrupt\n%% ");
}
\end{lstlisting}

dove rispetto a shell1 abbbiamo come differenze:

\begin{itemize}
	\item dichiarazione di funzione: gestore del segnale
	\item if 1: si parla di segnali:
		
		\begin{itemize}
			\item signal: gli diciamo che se arriva il segnale allora eseguire la nostra funzione
			\item sig_int: ha un numero intero per forza di cose e lo andrà a mettere il kernel. il numero e1 ovviamnete il numero del sengale
		\end{itemize}
	\item definizione della funzione: quando il segnale arriva viene stampata una stringa
\end{itemize}

i processi si intergacciano con il modo esterno tramite delle funzionnalita dete inter process communication ipc alcune di queste osno i segnali. sono schiamati i segnali anche software interrupt (hardware interrupt: periferiche che fanno arrivare degli interrupt al processore da alcune linee prefissate. arriva un numero detto interrupt hardware che fa capire se è un segnale per la pressione di un tasto o di un mouse. appena arriva il nbumero il sistema ha una tabella deli interrupt dove c'è l'indirizzo di una routine da fare lasciando tutto quello che stava facendo per eseguire l'interrupt endler e poi ricontinua quello che stava facendo)


nei software interrupt il kernel prende un processo in esecuzione, che esegue le due istruzioni, interrompe l'esecuzione e fa succedere delle cose, nel frattempo l'esecuzione del programma è bloccata. se il segnale non causa danni il porcesso riprende da dove era stato interrotto. è sempre il kernel a mandare i segnali. molto spesso i segnali son ocausati anche da condizioni particolari come divisioni per 0 o il porcesso cerca di accedere ad aree di memoria che ha a disposizione ma cdeve prima chiedere il permesso. un esempi odi richiesta di permesso di utilizzo di una certa area di memroia è la malloc. il messaggio di errore è segmentation folt.

un altra condizione è stoppare i programmi dove l'esito non è letale dato che si ferma e basta ma poi lo si può far partire.

arriva un segnale ad un processo. puo succeder che il porcesso si sia cautelato e puo sucedere

1. azione di default (prodcesseo non si è caurtelato
2. ignorare il segnale
3. gestione del segnale: si riferisce al meccanismo degli hardware interrupt. in pratica possiamo scrivere un signal endler e possiamo fare un maniera asincrona eseguire in signale endler e poi continuare

\begin{lstlisting}
$ man signal
\end{lstlisting}


terminate process: 

create core image (before terminate process): fotocopia del core per capire cosa ha fatto eseguire il segnale


per far arrivare i sengali usiamo un builtin "kill" per SIGINT oppure usiamo $\textasciicircum\ C$. un altro segnale da tastiera per killare il processo è: SIGQUIT $ \textasciicircum\ \backslash $



valori del tempo:

il sistema gestisce il tempo che lo gestisce in secondi a partire dalla epoc 01/01/1970. poi il sistema mantiene pe ogni processo 3 tempi

\begin{itemize}
	\item clock time: tempo che è passato dal momento in cui è iniziato il programma quando è terminato
	\item user clock time: tempo speso dalla cpu che però non richiede l'intervento del kernel
	\item system clock time: tempo usato dall'intervento del kernel
\end{itemize}

gli ultimi 2 non sono la somma dato che in mezzo ci sono dei processi che intervengono.

a volte la loro somma può essere superiore alla prima se la somma di tutti i core che la eseguono su un processore multicore hanno un tempo loro

\begin{lstlisting}
$ time [nome programma]
\end{lstlisting}




Standard:

è iniziata la standardizazione da posix nel 1988. gli standard si ponevano di standardizzare le interfaccie queindi i porottipi dele funzionie C fece il suo inquesto. 

con posix 2 entrarono a far parte le utilies negli standard 1992 poi anche le thread nel 1995 con poisx.le

dal 1994 si è stabilito un consorsio che divenne proprietario del marchio UNIX che specificò le singol unit specification SUS che raccolgono tutto ciò c'era stato in prececdensza 


tener presente di:

pisix.1-2001 / SUSv3
posix.1-2008 / SUSv4

che contengono tutto ciò che usiamo ora

hanno definito

- bash come shell standard
- v3: standardizzazione delle utilitis


v4: molte delle cose che erano opzionali sono diventate obbligatorie. ma nessuno tranne 1 è certificato SUSv4

linux ha la cerficazione linux standard based LSB che è quella che più si avvicina alla SUSv4 ma in più si rifersce anche a delle implementazioni standard

non si son ocertificati in molti dato che si sono specificate sullo scambio di informazione in segnali realtime che posson ogestire delle massimizzazioni dei tempi e mandare un certo unmero di dati. quwsto è usato in automazioni aziendali 

SUSv3

http://pubs.opengroup.org/onlinepubs/009604599/

SUSv4

http://pubs.opengroup.org/onlinepubs/9699919799/


non stante gli standard ogni OS fa delle sue modifiche su alcune cose esterne alle SUS.

i codici di intestazione .h sono cosparsi di macro per capire cosa si vuole pordurre. queste vongon oin soccorso per imporre delle macro per un certo standard dette featrure test macros in modo da far imporre che vengano scelte alcune parti di codice invece di altre come per -DMACOS o -DLINUX

una macro fondamentale per capire quel compilaizone si vuole è: _XOPEN_SOURCE con 600 SUSv3, 700 SUSv4

\begin{lstlisting}
-D_XOPEN_SOURCE=600
\end{lstlisting}

in qeusto modo potremo allora andare a compilare tutti i programmi conformi.

notare che le vesioni sono back compatibili. infatti se il sistema è SUSv4 se andiamo ad impostare _XOPEN_SOURCE = 600 allora il sistema si presenterà come SUSv3.


macro per dice cosa supporta il sistema: _XOPEN_VERSION.



limiti:
abbimao dei limiti di compilazione che possono essere visti nei file di inestazione

runtime limit: si vedono tramite la ufnzione sysconf (es: lunghezza massima del nome dei file che dipende dal filesystem può capirlo tramite pathconf su un file qualunque di quel filesystem)

sysconf:
